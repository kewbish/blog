<!doctypehtml><html lang=en><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Making OPAQUE Clear</title><meta name=description content="On becoming less oblivious to OPRFs."><meta property=og:title content="Making OPAQUE Clear"><meta property=og:description content="On becoming less oblivious to OPRFs."><meta property=og:url content="https://kewbi.sh/blog/posts/241020/"><meta property=twitter:title content="Making OPAQUE Clear"><meta property=twitter:description content="On becoming less oblivious to OPRFs."><link rel=icon href=https://kewbi.sh/small-logo.png><link
  rel="preload"
  as="text/woff2"
  href="https://kewbi.sh/fonts/playfair-display-v30-latin-italic.woff2"
/>
<link
  rel="preload"
  as="text/woff2"
  href="https://kewbi.sh/fonts/playfair-display-v30-latin-700.woff2"
/>
<link
  rel="preload"
  as="text/woff2"
  href="https://kewbi.sh/fonts/source-sans-3-v8-latin-regular.woff2"
/>
<link rel=stylesheet href=https://kewbi.sh/css/main.css><link rel=stylesheet href=../../css/main.css><body class="page page-padding"><main class="main b-post-main"><p><a href=../../posts >‹ go back</a><div class=b-post><h1 class=display-title>Making OPAQUE Clear.</h1><p style=text-indent:0>Published 20 October 2024 at <a href='https://kewbi.sh/blog/posts/241020/'>Yours, Kewbish</a>.  4,807 words. Subscribe via <a href=../../index.xml>RSS</a>.<hr><div class=b-writing><h2 id="introduction">Introduction</h2>
<p>I am not a cryptographer. I&rsquo;ve participated in enough CTFs to have had the refrain &ldquo;never roll your own crypto&rdquo; drilled into my head. Leave the group-modulo-n wrangling to the professionals, as the undertone went. While I won&rsquo;t encourage you to do so, today I&rsquo;ll give you enough of the basics to implement your own key exchange protocol. I&rsquo;ll leave the deploying it to prod to you.</p>
<p>To build up some backstory: I recently met someone, who, when I asked to exchange contacts, told me to add them on Signal, instead of Discord or Whatsapp. This was new. A few years earlier, I&rsquo;d had the same reaction when I needed to join some group chats that were hosted on Telegram<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>. I&rsquo;ve just finished <a href="https://mitpress.mit.edu/9780262548182/tor/">a book about Tor</a> for a reading group, and attended a couple talks about <a href="https://en.wikipedia.org/wiki/Mix_network">mixnets</a>. While it might have something to do with the fact that my office is in the <a href="https://www.cambridgecybercrime.uk/">Cybercrime Centre</a>, recent news like the <a href="https://en.wikipedia.org/wiki/Pavel_Durov#2024_arrest_and_indictment">arrest of the Telegram founder</a> and the <a href="https://docs.google.com/document/d/1iWCqmaOUKhKjcKSktIwC3NNANoFP7vPsRvcbOIup_BA/edit?tab=t.0">viral AR I-XRAY glasses</a> have been bringing up topics around privacy and security.</p>
<p>To me, a core thread running through these concerns is the question of who we can trust with our data. There are growing movements to <a href="https://en.wikipedia.org/wiki/DeGoogle">abandon big-tech platforms</a> and use dumb phones without internet. Folks hop between the secure messaging platforms de jour, or at least onto the incumbent, which appears to be Signal. Signal, Protonmail, even something as familiar as Whatsapp: they&rsquo;re all end-to-end encrypted. This means the servers that run these platforms only store encrypted copies of your data, and the only people who can read your funnier-in-your-head texts are you and the intended recipient. This encryption usually uses big random numbers instead of passwords, since passwords are lower-entropy. These platforms also (usually) won&rsquo;t store your keys for you, since that&rsquo;d undermine the whole point of end-to-end encryption. You&rsquo;re therefore the only person in the world who can correctly decrypt any messages that are sent — nice and safe. But what happens when you lose your phone? Sure, the app prompted you to save a recovery file, store a twelve-word recovery phrase, or back up your keys somewhere before proceeding, but like most folks, you&rsquo;d probably just skipped past that step.</p>
<p>Let&rsquo;s use passwords, you say — folks know how to use them, they generally do a better job at recording them somewhere, and there are password manager tools readily available so it&rsquo;s rare you&rsquo;ll forget them. However, even besides the myriad misconceptions about strong passwords and the dangers of people reusing passwords, there&rsquo;s the fundamental problem that the platform&rsquo;s server will have to store your password. Nowadays, it&rsquo;s usually stored hashed, so that&rsquo;s mostly fine — should someone break into the service&rsquo;s database, their only choice is to brute-force or <a href="https://en.wikipedia.org/wiki/Rainbow_table">rainbow-table</a> their way to steal your original password.</p>
<p>Now consider what happens in between you hitting &lsquo;Log in&rsquo; on the auth page and the server processing your password — or more precisely, how the bytes of your password are transmitted. Yes, hopefully in this day and age it goes through TLS, so no one should be able to read it. But the core problem is that <em>it&rsquo;s still in plaintext</em>. Once the server receives your password via HTTP, it still needs to read and process it into a hash, to compare against the stored hash. And how is this processing done? In plaintext. That puts a lot of trust on the server to behave honestly. Even if the server behaves as expected, the hardware it runs on might be vulnerable to attacks: because the password is transmitted in plaintext, it&rsquo;s also in the RAM and cache in plain text. When I was at Cloudflare, I learned about some of the ways the team architected the Workers platform explicitly for better isolation on all levels, guarding against <a href="https://developers.cloudflare.com/workers/reference/security-model/">speculative execution bugs</a>, for example. If the server&rsquo;s using plain passwords, it&rsquo;s vulnerable to SPECTRE and other lower-level attacks like it.</p>
<p>It seems, then, that there&rsquo;s no safe option. Either you have better security at the risk of fallible users losing access to their data, or you get a more familiar user experience at the expense of many layers of security concerns. However, there&rsquo;s a way to augment passwords with some neat cryptography so that you can effectively get the best of both worlds. Enter OPAQUE: a password-based key exchange protocol that lets the end user input a password and save their keys on the server, while not allowing the server any access to the password. It retains the server-has-zero-knowledge properties that we&rsquo;d expect in an E2E setting and requires both user and server to participate in any login attempts, reducing the feasibility of brute-force attacks. OPAQUE was selected for standardization by the IETF over several other similar password-based protocols, including the other top contender <a href="https://en.wikipedia.org/wiki/Secure_Remote_Password_protocol">SRP-6a</a>, because of this defense against brute-force attacks. It&rsquo;s also been implemented by several companies, including <a href="https://blog.cloudflare.com/opaque-oblivious-passwords/">Cloudflare</a> and <a href="https://github.com/facebook/opaque-ke">Facebook</a>.</p>
<p>In my current research internship, I&rsquo;ve been working with variants of OPAQUE as applied to key recovery for E2E services. We&rsquo;re figuring out how to adapt OPAQUE to store and retrieve a user&rsquo;s private key via a password: for example, in cases where they&rsquo;ve lost access to their old devices. We needed OPAQUE&rsquo;s properties: we don&rsquo;t want the server to be able to reconstruct the password and read the user&rsquo;s keys, nor do we want the user to keep the only copy of keys locally and end up susceptible to brute-force if any encrypted info leaks. We&rsquo;re adding some other goodies on top, too, but I had to implement a vanilla version first. When I was doing so, I had to trawl through tens of pages of dense crypto papers and cross reference the <a href="https://www.ietf.org/archive/id/draft-irtf-cfrg-opaque-17.html">OPAQUE spec</a> with the myriad <a href="https://github.com/search?q=opaque+protocol&amp;type=repositories">example repos</a>, but I think the core ideas boil down much more intuitively.</p>
<p>Protocols like OPAQUE shouldn&rsquo;t be secure-by-obscurity, and certainly not secure-by-lack-of-good-high-level-public-explanations. This post aims to give you the walkthrough of OPAQUE I wish I had when I embarked on this project. I&rsquo;ll assume some general CS knowledge, but otherwise I&rsquo;ll provide the context you need if you&rsquo;re starting from scratch. I&rsquo;ve chosen to gloss over some of the related crypto concepts to focus on just what&rsquo;s needed to understand the OPAQUE exchange, but I&rsquo;ve included links and mentioned other keywords if you&rsquo;d like to dive deeper.</p>
<p>I hope this post will serve to make OPAQUE clear and you less wary about crypto — reams of LaTeX can be scary, but I promise this won&rsquo;t be.</p>
<h2 id="background-elliptic-curves">Background: Elliptic Curves</h2>
<p>One of the concepts I&rsquo;ll assume some background in is <a href="https://en.wikipedia.org/wiki/Public-key_cryptography">public-key cryptography</a>. The basic idea is that you store two keys: one public and one private. You share your public key with others, and keep your private key to yourself, as the names may suggest. To encrypt something, you take your private key and the public key of the intended recipient together and do some operations on it, which ensures that only the recipient can decrypt your message, since only they have the private key associated with their public key. The idea is that public keys are derived from private keys using some hard-to-reverse operation, and that you can easily derive the public key from the private key, but not vice versa. For example, multiplying numbers is easy, but factoring numbers is hard, so part of what underlies the <a href="https://en.wikipedia.org/wiki/RSA_(cryptosystem)">RSA cryptosystem</a> is that you can&rsquo;t easily factor numbers to derive the secrets that are used to create the private key<sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup>.</p>
<p>Elliptic-curve cryptography works on the same principle. The hard-to-reverse operation here is multiplying a point on the curve with a number. Let&rsquo;s build up to multiplying with points on the curve by first adding a point to itself, which we can then repeat <em>n</em> times to get multiplication by <em>n</em>.</p>
<p>We first have to start with the given point on the curve. The formula of this curve will change depending on the particular curve you use (and there are plenty), so I won&rsquo;t go into detail about it now. Pick a point <code>P</code>. To add the point to itself, you&rsquo;ll need to draw the tangent line to the curve at <code>P</code> — this is the line that follows the shape of the curve at point <code>P</code>. Extend the tangent line far enough, and you&rsquo;ll find that it intersects exactly one point on the curve. Call this point the tangent line intersection.</p>
<figure><img src="../../img/241020/adding-points-1.png"
         alt="Figure 1. Drawing the tangent line to P."/><figcaption>
            <p><em>Figure 1. Drawing the tangent line to P.</em></p>
        </figcaption>
</figure>

<p>This tangent line intersection point is then reflected in the x-axis to get the doubled point, <code>2P</code>.</p>
<figure><img src="../../img/241020/adding-points-2.png"
         alt="Figure 2. Reflecting across the x-axis to get 2P."/><figcaption>
            <p><em>Figure 2. Reflecting across the x-axis to get 2P.</em></p>
        </figcaption>
</figure>

<p>We can then repeat this again, with the tangent line for the point <code>2P</code>, to get <code>3P</code>, and so on. There are several optimizations to do this multiplication faster, including the <a href="https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication#Double-and-add">double-and-add</a> algorithm.</p>
<figure><img src="../../img/241020/adding-points-3.png"
         alt="Figure 3. Repeating to find 3P."/><figcaption>
            <p><em>Figure 3. Repeating to find 3P.</em></p>
        </figcaption>
</figure>

<p>The private key in elliptic curve cryptography is the choice of a number <code>n</code>, and the public key is the curve&rsquo;s basepoint multiplied by <em>n</em>. The curve&rsquo;s basepoint is a point that&rsquo;s defined along with the curve (technically, the generator of the group we&rsquo;ll be operating in) — just consider it as a constant that&rsquo;s handed to you together with the definition of the curve. It&rsquo;s easy to compute the public key given the private key, since the multiplications aren&rsquo;t hard. However, if you want to recover the private key given just the resulting public key point, you&rsquo;ll have to try every single possible value of <code>n</code>, which is assumed to be infeasible. This multiplication is called the <a href="https://en.wikipedia.org/wiki/Discrete_logarithm_records#Elliptic_curves">elliptic curve discrete log problem</a>, as an analogy to the discrete log problem of finding the number <code>x</code> such that <code>g^x = y</code> for some public number <code>y</code>.</p>
<p>One thing to note is that if you know the number <em>n</em> that you multiplied by, it&rsquo;s easy to &lsquo;undo&rsquo; a multiplication as well. You can multiply by its inverse — think of it like doing <code>n * P * 1/n</code> — to recover just your original point. You might wonder why we can&rsquo;t do something similar to recover the number <code>n</code> from our public point, since the curve&rsquo;s basepoint is a public parameter. However, you can&rsquo;t analogously &lsquo;invert&rsquo; a point, so you&rsquo;ll still have to end up trying all the possible values of <code>n</code>. The core takeaway of all this is that division by a number is easy, and division by a point to get the number back is hard.</p>
<h2 id="metam-oprf-asis">Metam-OPRF-asis</h2>
<p>Let&rsquo;s put that elliptic curve theory to work, starting with the main building block of OPAQUE: the oblivious pseudo-random function (OPRF). We can build up what an OPRF is step by step:</p>
<ul>
<li>A function is a mapping from a domain of inputs to a range of outputs.</li>
<li>A <a href="https://en.wikipedia.org/wiki/Pseudorandom_function_family#Motivations_from_random_functions">random function</a> is an entirely random mapping from inputs to outputs. This means the random outputs should be <a href="https://en.wikipedia.org/wiki/Randomness_test">uniformly distributed</a>, which means there&rsquo;s no obvious bias in the outputs.</li>
<li>A pseudo-random function <em>looks</em> like it&rsquo;s an entirely random mapping, but is actually deterministically mapping inputs to outputs. It&rsquo;s very important that it <em>looks</em> like a random function, so it also needs to have a uniform distribution of outputs.</li>
<li>An oblivious pseudo-random function is a random function that requires two people to evaluate, where neither person learns what the other put in — they&rsquo;re <em>oblivious</em> to the other party&rsquo;s input.</li>
</ul>
<p>More concretely, let&rsquo;s describe the two people as a client and a server and define an OPRF as a function <code>F(server_input, client_input)</code> such that the client never learns the server input, and the server never learns the client input nor even the final result of the function. I think <a href="https://en.wikipedia.org/wiki/Oblivious_pseudorandom_function">Wikipedia</a> and other resources do a terrible job of explaining how this is possible, because intuitively, it isn&rsquo;t. How can the server, who&rsquo;s evaluating the function, not know its own output? How can the server also not know the client&rsquo;s input, if it was required as part of the function&rsquo;s inputs in the first place?</p>
<p>The answer lies in the elliptic-curve operations I touched on before. Here&rsquo;s how the OPRF actually works:</p>
<figure><img src="../../img/241020/oprf-exchange.png"
         alt="Figure 4. The full OPRF exchange."/><figcaption>
            <p><em>Figure 4. The full OPRF exchange.</em></p>
        </figcaption>
</figure>

<ul>
<li>The client has <code>x</code>, which is a number it wants to keep secret. It multiplies this point by the curve&rsquo;s basepoint, so now we have a point. Let&rsquo;s call this point <em>x_point</em>.</li>
<li>To keep it secret, the client generates a random number <code>r</code>, which is called the <a href="https://en.wikipedia.org/wiki/Oblivious_pseudorandom_function#EC_and_conventional_Diffie%E2%80%93Hellman"><em>blinding factor</em></a>. The client calculates <code>r * x_point</code> and sends that to the server as <code>client_input</code>. The server doesn&rsquo;t know <code>r</code>, so it can&rsquo;t get the original <code>x_point</code> back. This protects the server from learning what the client inputted, but it&rsquo;s easy for the client to undo this later.</li>
<li>The server receives <code>client_input</code>, and multiplies it by its own secret number, <code>server_input</code>. (In the diagram, I called this secret number <code>key</code> to save space.) This makes the output <code>= client_input * server_input = r * x_point * server_input</code>. The server can&rsquo;t learn the actual execution output without the blinding factor <code>x_point * server_input</code> nor the <code>x_point</code> itself, because that pesky <code>r</code> is there.</li>
<li>The client receives <code>output</code>, and multiplies it by <code>1/r</code>. This lets it recover <code>server_input * x_point</code> — remember that division by a number is easy. However, the client still can&rsquo;t learn <code>server_input</code> either — remember that division by a point (<code>x_point</code>) is hard.</li>
</ul>
<p>To summarize:</p>
<ul>
<li>We want to end up with the client&rsquo;s input multiplied by the server&rsquo;s input, without either party knowing the other&rsquo;s value.</li>
<li>The property that dividing by points is hard prevents the server from learning the client&rsquo;s blinding factor or secret point and similarly prevents the client from learning the server&rsquo;s secret.</li>
<li>The property that dividing by numbers is easy enables the client to unblind the result to get the required <code>client_input * server_input</code>.</li>
</ul>
<h2 id="registration">Registration</h2>
<p>That&rsquo;s actually all the hard crypto out of the way! Let&rsquo;s now cover the three main phases of OPAQUE: the registration, login, and key exchange. The first phase is registration, where the user will use their password (a string) in an OPRF exchange to get an encryption key that only they know that they then can use to encrypt their keypair data.</p>
<p>The registration revolves around an OPRF exchange.</p>
<figure><img src="../../img/241020/opaque-registration.png"
         alt="Figure 5. OPAQUE registration."/><figcaption>
            <p><em>Figure 5. OPAQUE registration.</em></p>
        </figcaption>
</figure>

<ul>
<li>The client transforms their password into a point on the curve. This is done via <a href="https://datatracker.ietf.org/doc/rfc9380/">&lsquo;hash-to-curve&rsquo; functions</a> that allow you to take arbitrary inputs to points on the curve. This is the <code>x_point</code> in the OPRF explanation above. The client then blinds their password point with some random blinding factor, <code>r</code>.</li>
<li>The server receives this <code>client_input</code>. The server generates a user-specific keypair that&rsquo;ll just be used for this user. This user-specific private key will be the <code>server_input</code> in the OPRF explanation above. It multiplies the <code>client_input</code> with its <code>server_input</code> and returns this value to the client, along with the server&rsquo;s public key.</li>
<li>The client receives this <code>output</code> and unblinds it. The client now has <code>x_point * server_input</code>. Let&rsquo;s call this unblinded output <code>rwd</code> — it&rsquo;ll be used as the key to (symmetrically) encrypt what we call the <em>envelope</em>.</li>
<li>The client generates an <em>envelope</em>, which includes a new keypair that the client will use in communications with this server. It also puts the server&rsquo;s public key into this envelope. The client then encrypts all of this with the <code>rwd</code> and sends the encrypted envelope to the server.</li>
<li>The server saves the encrypted envelope so the user can access it again later. It can&rsquo;t decrypt this envelope, since it has no way of unblinding its output to recover the <code>rwd</code>.</li>
</ul>
<p>Note that in every step of this process, the server will never learn the password nor the <code>rwd</code> used to encrypt the envelope, so the client can safely trust the server to store its information. This is critical for end-to-end encryption systems.</p>


<div class="grid-element" style="margin-bottom: 0.5em">
<details>
<summary>
A fun challenge: given the protocol as specified above, can you find the DOS attack vector?
</summary>
<hr>
<p>
It's possible for a malicious user masquerading as the client to intercept the server's output and unblind it with some random number, making the `rwd` that the malicious user calculates meaningless. This doesn't matter, though, because it can then encrypt jibberish with the `rwd` or just directly send junk to the server, which will happily store it under the original user's identifier. When the original user tries to log in, they won't be able to decrypt the envelope they retrieve from the server, which effectively DOSes their account for any future use. This means there needs to be some way of checking that the original user is the same one who provides the blinded input and the encrypted envelope.
</p>
<p>
My supervisor pointed this out in my initial implementation of OPAQUE, and I was pretty confused when I saw that none of the other implementations on GitHub handled this in any way. I ended up asking <a href="https://github.com/expede">Brooke Zelenka</a> about it, and she pointed me to <a href="https://www.ietf.org/archive/id/draft-irtf-cfrg-opaque-17.html#name-registration">this section of the OPAQUE spec</a>, which states that registration requires some other method of the server authenticating the client to ensure that it's talking to the right one. I think you can get past this if you assume enough things about the communication channel on which messages are exchanged, but I just slapped some signatures onto the messages to ensure authenticity and called it a day.
</p>
</details>
</div>


<h2 id="logging-in">Logging in</h2>
<p>Logging in also relies on a similar OPRF exchange. This time, the user needs to recover <code>rwd</code> so it can decrypt the encrypted envelope that the server returns.</p>
<figure><img src="../../img/241020/opaque-login.png"
         alt="Figure 6. OPAQUE login."/><figcaption>
            <p><em>Figure 6. OPAQUE login.</em></p>
        </figcaption>
</figure>

<ul>
<li>The client transforms their password into the same point on the curve, and chooses a new random blinding factor <code>r</code>. The client blinds their password point and sends it over.</li>
<li>The server receives this <code>client_input</code> and multiplies it with the same <code>server_input</code> secret that it used during registration. The server sends this <code>output</code> along with the stored encrypted envelope to the client.</li>
<li>The client receives this <code>output</code> and their envelope. It unblinds the <code>output</code> to recover the <code>rwd</code> and uses the <code>rwd</code> to decrypt the envelope. The user has now recovered their service-specific keypair and can move onto a key exchange or further communications with the server, since the decrypted envelope will include the server&rsquo;s public key.</li>
</ul>
<p>The two main benefits of OPAQUE were that it prevents the client and server from learning anything about what the other party&rsquo;d stored or used to compute the function and that it avoids offline brute-force attacks. We&rsquo;ve previously discussed how the OPRF provides this first property via the blinding factors and elliptic-curve cryptography, but let&rsquo;s also briefly touch on the brute-force attack part. Without the OPRF, you might just encrypt the envelope with your password directly and send that to the server to store. This is both less secure than using a key, which is likely longer and has more entropy, but also allows any malicious parties, including a dishonest server, to intercept your encrypted envelope and mount an offline brute-force attack. In theory, the cryptography should ensure this takes a very long time, but the OPRF gives you the additional guarantee that any attacker must interact with the server to get their password guess multiplied by the <code>server_input</code>. This means the server is able to detect and rate-limit password attempts, making brute-force much slower than it would be otherwise.</p>
<h2 id="the-ke-rry-on-top">The KE-rry On Top</h2>
<p>The final piece of OPAQUE is the key exchange that needs to follow in order to derive a shared secret with which to encrypt all following communication. I focused less on this part of the protocol, since for my project we were only interested in the recovery of the client&rsquo;s keypair from the envelope. As well, once you&rsquo;re done with the OPRF exchanges, you&rsquo;re in some sense &lsquo;back in safe territory&rsquo; — there are plenty of key exchange protocols proposed, and you could probably plausibly choose any one of them. <a href="https://eprint.iacr.org/2005/176.pdf">HMQV</a>, a Diffie-Hellman variant, was chosen in the original <a href="https://eprint.iacr.org/2018/163.pdf">OPAQUE paper</a> for its performance. However, <a href="https://blog.cloudflare.com/opaque-oblivious-passwords/">Cloudflare&rsquo;s OPAQUE explainer</a> leverages TLS as an AKE, and the <a href="https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-opaque-01">specification</a> mentions another variant using a <a href="https://www.iacr.org/cryptodb/archive/2003/CRYPTO/1495/1495.pdf">SIGMA-I</a> Diffie-Hellman variant.</p>
<p>For the sake of completeness, I&rsquo;ll briefly cover the HMQV calculation used in the original OPAQUE paper. We want to derive a shared secret that both the client and server can calculate, and use this as a key going forward.</p>
<ul>
<li>As part of the login (or in a separate round-trip message), the client chooses a random number <code>c</code>. It multiplies the curve&rsquo;s basepoint with this to get a public point <code>C</code>. This is sent to the server.</li>
<li>Likewise, the server chooses a random number <code>s</code> and multiplies it with the curve&rsquo;s basepoint to get <code>S</code>.</li>
<li>Both client and server then compute a couple of hashes (remember that these are effectively numbers, not points.) First, the client computes <code>blinded_session_identity = H(client_identity, server_identity, r)</code> with its blinding factor. Then, let <code>e_u = H(C, server_identity, blinded_session_identity)</code> and <code>e_s = H(s, server_identity, blinded_session_identity)</code>. The exact details of this are less important to the overall protocol — this just ensures you&rsquo;re talking to the right person.</li>
<li>Then, the client computes its shared secret as <code>H((S + e_s * server_public_key) * (c + e_c * client_private_key))</code> and the server computes <code>H((C + e_c * client_public_key) * (s + e_s * server_private_key))</code>. The first parenthesis of each expression contains the public parameters that are known from the other party, and evaluates to a point; the second parenthesis contains the private parameters from the party computing the hash and evaluates to a number.</li>
</ul>
<p>If we expand both sides, we&rsquo;ll see that what&rsquo;s being hashed is the same. Feel free to skip the proof if you&rsquo;re happy to just trust that the above are equal, but it&rsquo;s neat looking at variants of Diffie-Hellman to prove how both client and server derive the same secret. I&rsquo;d encourage you to give it a go — it&rsquo;s very satisfying to see everything fall into place and the base math isn&rsquo;t challenging, though keeping all the variables in line and recognizing when to factor terms in and out can be a nice puzzle. Let <code>G</code> be the curve basepoint:</p>
<pre tabindex="0"><code>  (S + e_s * server_public_key) * (c + e_c * client_private_key) // what the client hashes
= (s * G + e_s * server_public_key) * (c + e_c * client_private_key)
= (s * G) * (c + e_c * client_private_key) + (e_s * server_public_key) * (c + e_c * client_private_key) // distribute the multiplication
= (s * G * c) + (s * G * e_c * client_private_key) + (e_s * server_public_key) * (c + e_c * client_private_key)
= (s * G * c) + (s * G * e_c * client_private_key) + (e_s * server_private_key * G) * (c + e_c * client_private_key)
= (s * G * c) + (s * G * e_c * client_private_key) + (e_s * server_private_key * G * c) + (e_s * server_private_key * G * e_c * client_private_key)
= (s * G * c) + (e_s * server_private_key * G * c) + (s * G * e_c * client_private_key) + (e_s * server_private_key * G * e_c * client_private_key) // rearranged terms
= (s * G + e_s * server_private_key * G) * c + (s * G + e_s * server_private_key * G) * e_c * client_private_key // factor out c and e_c * client_private_key
= (s + e_s * server_private_key) * c * G + (s + e_s * server_private_key) * e_c * client_private_key * G // factor out G
= (s + e_s * server_private_key) * (c * G + e_c * client_private_key * G) // factor out first term
= (s + e_s * server_private_key) * (C + e_c * client_public_key)
= (C + e_c * client_public_key) * (s + e_s * server_private_key) // what the server hashes
</code></pre><p>This completes the authenticated key exchange, and in turn, the OPAQUE protocol!</p>
<h2 id="conclusion">Conclusion</h2>
<p>When I was first looking into implementing OPAQUE, my supervisor sent me the original paper as some helpful reading, but after seeing the PDF was 61 pages long, I bailed out to go read through the <a href="https://blog.cloudflare.com/opaque-oblivious-passwords/">Cloudflare explainer</a> instead. The original paper only has the full protocol laid out on page 47! The rest of the paper, and even the protocol description itself, is very dense — I suppose it&rsquo;s nicely concise for those who have been in the field for long enough that they can parse the math at first glance, but trudging through all of that isn&rsquo;t fun for a first-timer. I found the crypto explainers in general to also be at weird levels of abstraction that didn&rsquo;t immediately make it clear how primitives built together, particularly for topics like elliptic-curve cryptography or OPRFs.</p>
<p>In general, I&rsquo;ve noticed that theoretical crypto papers always start with a sea of security games where they prove the correctness and security of their protocol, but not actually explain the protocol until later, as if the protocol is an afterthought that derives naturally from the security games. Again, this probably makes sense for the cryptographers who are focusing on the security, but you&rsquo;d think you&rsquo;d put your major contribution up front in the paper. Another thing I&rsquo;ve noted about crypto papers is how little discussion they usually have. Unless it&rsquo;s an applied crypto paper where the system has been fully implemented and benchmarked, there&rsquo;s usually at most a page or so of discussion, which mostly consists of re-explaining that they protocol is better than the others that currently exist. The conclusion is also usually on the order of a paragraph or two, which is a far cry from the systems/HCI papers that I&rsquo;d read. As well, one thing that&rsquo;s nice is that the modern crypto papers in major journals are mostly all available freely via the <a href="https://iacr.org/publications/">IACR</a>. Having almost all my references centralized on the IACR archives and the IACR having a sequential numbering scheme have had the side effect of me memorizing the numbers of the key papers I&rsquo;ve been referencing over and over again, to the point that I can type in the first digit out of the three or four digit ID and have Chrome autofill the rest as the first search result. Such is crypto research.</p>
<p>I came into this project not really having much crypto background besides understanding the basics of public key cryptography and what an elliptic curve was. The main resources I used to hack my way through were Wikipedia entries, which were usually less notation-heavy than papers, Cloudflare explainers published via their blog, and, in an unusual-for-me turn, ChatGPT. It&rsquo;s surprisingly decent at explaining crypto and math topics — I was very wary of it getting things wrong, but it turns out even if it&rsquo;s messing up some of the details, it&rsquo;s good enough at imparting the intuition that lets you get a skeleton of an implementation done, enough to check it against the expected outputs from Wikipedia or the actual paper. I did write the code myself, since it wasn&rsquo;t quite understanding the libraries I needed to use, but it did a fair job of pointing me in the right direction or mentioning keywords (even if they were explained in the wrong contexts) that I could check against other resources. I&rsquo;m decidedly less anxious about using ChatGPT as an assistant now, and I expect it to keep giving me enough nudges to make my way to the end of my project.</p>
<p>Anyways, I hope this explainer has been clearer than the usual seas of math notation that never tell you how things fit together or how the intuition works. I&rsquo;m thinking of doing the same sort of explainer for some other cryptography topics that I&rsquo;ve had to wrestle with for my project recently, like Shamir secret sharing. As my supervisor said, warning people not to roll their own crypto is a bit patronizing when you think of it: it discourages folks from really understanding the protocols they&rsquo;re relying on and creates this out-group of folks who think they&rsquo;re not good enough to do crypto. It emphasizes this mindset where people aren&rsquo;t trusted to understand any crypto well enough to not mess it up. While this was probably trying to prevent people from writing their own very easily breakable ciphers and things of that more trivial nature, I think it&rsquo;s a bit of a gatekeep-y refrain. Go forth and implement your own OPAQUE — hopefully this explainer has made you a little less oblivious to OPRFs and OPAQUE and how to build them!</p>
<div class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1">
<p>Admittedly, not generally known for being truly secure, particularly against malicious Telegram employees, but it marketed itself as something different to the conventional chat platforms I&rsquo;d used before then.&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2">
<p>When I say &lsquo;hard&rsquo; in this post, I generally mean &lsquo;currently no one thinks it&rsquo;s possible&rsquo;, but that doesn&rsquo;t roll off the tongue quite so well. If it makes you happier, replace &lsquo;hard&rsquo; with &lsquo;requires exponential-time brute-force&rsquo;, and &rsquo;easy&rsquo; with &lsquo;polynomial-time or less&rsquo;.&#160;<a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</div>
</div><br></div><p><a href=../../posts >‹ go back</a></main><script data-goatcounter="https://yours-kewbish.goatcounter.com/count" async src="//gc.zgo.at/count.js"></script>
