<!DOCTYPE html>
<html lang="en" id="top">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CS50: Week 5</title>
    <meta name="description" content="On my final encounters with C.">
    <meta property="og:title" content="CS50: Week 5">
    <meta property="og:description" content="On my final encounters with C.">
    <meta property="og:image" content="https://i.imgur.com/QxvZ9Tv.png">
    <meta property="og:url" content="https://kewbi.sh/blog/posts/200719/">
    <meta property="twitter:title" content="CS50: Week 5">
    <meta property="twitter:description" content="On my final encounters with C.">
    <meta property="twitter:image" content="https://i.imgur.com/QxvZ9Tv.png">
    <link rel="stylesheet" href="../../css/main.css">
</head>

<body class="cont page">
    <section class="main-2">
        <p><a href="../">&lt; More Posts</a></p>
        <h1 class="subtitle">CS50: Week 5</h1>
        <p>Published 19 July 2020 at <a href="https://kewbi.sh/blog/posts/200719/">Yours, Kewbish</a>. 1264 words. Subscribe via <a href="../../index.xml">RSS</a>.</p>
        
        <p>Also published on <a href="https://dev.to/kewbish/cs50-week-5-113g">Dev.to</a>.</p>
        
        <div class="writing">
            <h2 id="introduction">Introduction</h2>
<p>Finally, we&rsquo;re over the worst of CS50 (in my opinion, at least). Week 5 was a bit of a difficult lesson and problem set, but in the end, it <em>actually</em> wasn&rsquo;t as hard as I thought it&rsquo;d be.<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup> Week 5 covers data structures - detailing hash tables, linked lists, and tries, which are a combination of both! Speller was a decent challenge, and for once, I really felt that I was applying what I learned in lecture to the problem. This is the week I was looking the most forward to (my original purpose for taking CS50 was for data structures and algorithms after all), and dreading as well.</p>
<h2 id="notes">Notes</h2>
<p>Alright, here are my notes:</p>
<ul>
<li>you can&rsquo;t reassign something if it doesn&rsquo;t exist yet
<ul>
<li>remember to initialize to a chunk of memory</li>
</ul>
</li>
<li>also, you should remember malloc&rsquo;s effects if you reassign, and free if you reassign a malloc</li>
<li>arrays are difficult to resize, because they&rsquo;re initialized to a certain amount of memory
<ul>
<li>could move a copy of the array to a larger, free area</li>
<li>then can delete old copy</li>
</ul>
</li>
<li>we could also use realloc
<ul>
<li>as its name implies, it reallocates memory</li>
<li>give it the pointer of the old array</li>
<li>will return address of new array</li>
<li>remember to free variable</li>
</ul>
</li>
<li>data structures are custom structures to store information
<ul>
<li>made with structs</li>
<li>builds off included data types</li>
</ul>
</li>
<li>linked lists
<ul>
<li>basically an array, but each element points to the next one</li>
<li>elements are not together in memory</li>
<li>each element includes a pointer to the next</li>
</ul>
</li>
<li>can&rsquo;t access the middle of the list with just <input checked="" disabled="" type="checkbox"> notation
<ul>
<li>there isn&rsquo;t a &lsquo;middle&rsquo;</li>
<li>need to navigate through the entire list first</li>
</ul>
</li>
<li>also takes twice as much memory per element
<ul>
<li>needs to store the next pointer</li>
</ul>
</li>
<li>usually constructed of a struct
<ul>
<li>one part to store the actual data, and the same struct pointing to the next struct</li>
<li>initialize first to NULL, so you can assign</li>
</ul>
</li>
<li>introduce a new notation, -&gt; notation
<ul>
<li>similar to dot notation of a pointer</li>
<li><code>node-&gt;next = x;</code></li>
</ul>
</li>
<li>need to use a while loop to iterate through the properties
<ul>
<li>check if not NULL</li>
<li>set the variable</li>
</ul>
</li>
<li>if you want to add to the beginning
<ul>
<li>set a pointer to point to the beginning</li>
<li>then set the list to the last pointer</li>
<li>inserts a node at the beginning</li>
</ul>
</li>
<li>to insert in the middle
<ul>
<li>do something similar</li>
<li>need to create a temporary variable for the swap</li>
</ul>
</li>
<li>linked lists are O(n) time, need to follow each node pointer to find the next</li>
<li>also introduces a tree
<ul>
<li>each node points to two nodes, like the famous binary search tree</li>
<li>makes binary search very easy, only compare two nodes</li>
<li>makes insertion easy as well, only rearrange a small subset</li>
<li>search is O(log n)</li>
</ul>
</li>
<li>need to balance these though, or else may become reweighted
<ul>
<li>also memory-expensive, but can search faster</li>
</ul>
</li>
<li>hashtable combines arrays and linked lists
<ul>
<li>each element in the array is a linked list</li>
<li>can add elements quickly, and the initial searching time is decreased</li>
<li>however, they might all end up in the same element, in which case the time efficiency is negated</li>
<li>get as close as possible to O(1) when the number of elements equals the possible values</li>
</ul>
</li>
<li>retrieval tree provides O(1) searching, but at cost of space
<ul>
<li>stores each level of element (here, letters) in a separate array</li>
<li>in this example, 26x as much memory</li>
</ul>
</li>
<li>more data structures
<ul>
<li>stacks -&gt; last in, first out, like email inbox</li>
<li>queue -&gt; first in, first out, like line in a store</li>
<li>dictionary -&gt; map keys to values, like Python!</li>
</ul>
</li>
<li>these data structures can be implemented with arrays, linked lists, hashtables, and other structures</li>
</ul>
<h2 id="problem-set">Problem Set</h2>
<p>This week wasn&rsquo;t much of a problem <em>set</em> - we only had Speller to work through. But don&rsquo;t underestimate it either - it took two consecutive days of work to finish out. The logic wasn&rsquo;t too hard to implement, actually. 
First, I split up the problem in its subparts</p>
<ul>
<li><code>hash</code> -&gt; I decided to use the simplest hash function - just the first character. Could this be optimized? Yes, but I just wanted to try the data structure out first, and not have to worry about copying a hash function that I didn&rsquo;t completely understand either.</li>
<li><code>load</code> -&gt; Made an array, and I&rsquo;d put each word into its appropriate element. I just appended the current word to the end of the linked list, and lowercased it as well.</li>
<li><code>size</code> -&gt; In load, I&rsquo;d created a line to increment a global variable, which made size just a <code>return count;</code> statement.</li>
<li><code>check</code> -&gt; I hashed the current word to compare, and then used a while loop to iterate over the linked list and checked if it matched the current targeted word.</li>
<li><code>unload</code> -&gt; I iterated over each element in the array, and again iterated over the linked list to free each pointer in the list.</li>
</ul>
<p>The first time I wrote the program, it worked as intended, so check. But, upon check50-ing, I got a bunch of valgrind errors. I had forgotten to free a bunch of malloc&rsquo;ed variables, and to fix this, I tried to use a character array instead. Also, I finally learned to use valgrind properly - I&rsquo;d kind of ignored it in the past week, given that there wasn&rsquo;t a check for a memory leak, just a reminder that it could exist. I also realized that my unload function was logically incorrect, and would always return true right away. After fixing this, I attempted to test it - but now, it didn&rsquo;t produce the intended output. Oops.</p>
<p>I stripped out the entire program, and rewrote it from scratch, including what I&rsquo;d learned about valgrind and memory allocation in the first runthrough. (Now that I think about it, I did have some confusion about <code>&gt;</code> vs <code>&gt;&gt;</code> in bash. They overwrite a file while redirecting output and append to a file while redirecting, respectively. I probably mixed <code>&gt;</code> up with <code>&gt;&gt;</code>, and that&rsquo;s actually probably why it didn&rsquo;t work as intended, meaning the logic was solid initially, meaning I rewrote it from scratch for essentially nothing. Big facepalm.)</p>
<p>Now, I was memory leak free, and working with the correct output. Nice! In the process of scrolling dozens of Stack Overflow pages, I really learned to appreciate the full power of valgrind. It&rsquo;s a great resource for checking memory leaks, and despite its rather scary, confusing interface, it&rsquo;s an essential tool, really. I never had to keep memory management in mind while Pythoning, but C made me more cognizant of the lower-level management that goes into the easy-to-learn Python flow.</p>
<h2 id="conclusion">Conclusion</h2>
<p>Am I going to continue with C? I doubt it, unless I&rsquo;m just making a toy thing, or <em>really</em> want performance for something. Would I have ignored C if I were to take some version of CS50 where I didn&rsquo;t need CS50? Probably not. I&rsquo;ve learned a lot about lower level things, like memory management and bytes, as well as getting a glimpse into how easy-to-use features in Python were really implemented. As other people have said, working with C makes one really appreciate how nice higher level languages like Python are to work with, and it was a great experience.</p>
<p>That said, I still can&rsquo;t wait to get into the later half of CS50 - Python, SQL, and web? Yes, thank you very much. I guess this would be the more <em>application</em> side of CS50, and I&rsquo;m excited to get learning.</p>
<section class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1" role="doc-endnote">
<p>The CS50 Reddit and my initial lack of experience with data structures were pretty scary. But I&rsquo;d rate this problem set lower than Tideman in difficulty, honestly. <a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</section>

            <p>- Yours, Kewbish</p>
        </div>
        <br><p><a href="../">&lt; More Posts</a></p>
        <br><br>
    </section>
    
</body>

</html>
