<!doctypehtml><html lang=en><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Kintsugi</title><meta name=description content="On decentralized E2EE key recovery."><meta property=og:title content="Kintsugi"><meta property=og:description content="On decentralized E2EE key recovery."><meta property=og:url content="https://kewbi.sh/blog/posts/250223/"><meta property=twitter:title content="Kintsugi"><meta property=twitter:description content="On decentralized E2EE key recovery."><link rel=icon href=https://kewbi.sh/small-logo.png><link
  rel="preload"
  as="text/woff2"
  href="https://kewbi.sh/fonts/playfair-display-v30-latin-italic.woff2"
/>
<link
  rel="preload"
  as="text/woff2"
  href="https://kewbi.sh/fonts/playfair-display-v30-latin-700.woff2"
/>
<link
  rel="preload"
  as="text/woff2"
  href="https://kewbi.sh/fonts/source-sans-3-v8-latin-regular.woff2"
/>
<link rel=stylesheet href=https://kewbi.sh/css/main.css><link rel=stylesheet href=../../css/main.css><body class="page page-padding"><main class="main b-post-main"><p><a href=../../posts >‹ go back</a><div class=b-post><h1 class=display-title>Kintsugi.</h1><p style=text-indent:0>Published 19 February 2025 at <a href='https://kewbi.sh/blog/posts/250223/'>Yours, Kewbish</a>.  4,917 words. Subscribe via <a href=../../index.xml>RSS</a>.<hr><div class=b-writing><h2 id="introduction">Introduction</h2>
<p>Last term, I wrote a couple of posts on cryptography concepts (on <a href="https://kewbi.sh/blog/posts/241020/">OPRFs</a> and on <a href="https://kewbi.sh/blog/posts/241229/">Lagrange interpolation</a>). In the conclusion of each of these posts, I&rsquo;ve alluded to a new, related project that I&rsquo;ve been working on this last term. That project is <a href="https://github.com/kewbish/kintsugi">Kintsugi</a>, and I&rsquo;ve recently had the opportunity to present it at <a href="https://fosdem.org">FOSDEM</a>, widely regarded as the biggest open-source conference around. I realized that I&rsquo;d never shared in-depth details about Kintsugi or how it works, and I thought I&rsquo;d edit and republish my talk in article format. This post is a capstone to this series of crypto explainers, highlighting how we&rsquo;ve combined ideas from both OPRFs and Lagrange interpolation to create a decentralized key recovery protocol for E2EE platforms.</p>
<p>Kintsugi&rsquo;s elevator pitch goes as follows: Using E2EE apps mean that you&rsquo;re solely responsible for keeping a copy of your keys, but what happens when you lose your device or backup files? E2EE apps like WhatsApp and Signal have recovery mechanisms, sure, but these schemes rely on one centralized provider that manages all the special hardware and servers that might be needed. Kintsugi is instead decentralized, based on a P2P network of recovery nodes. To recover your key, you use your password and communicate a threshold of your recovery nodes. Thanks to some fun crypto, though, these recovery nodes can&rsquo;t brute-force access to your data offline, and even colluding recovery nodes can&rsquo;t gain access to your account. Kintsugi doesn&rsquo;t rely on all of these nodes being reachable, just a threshold of them, so it can remain operational even if some recovery nodes go offline. Kintsugi therefore lets you use a familiar password-based authentication scheme while retaining E2EE security properties and protecting against brute-force and recovery node collusion.<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup></p>
<p>This post will first cover some prior E2EE key recovery work, including the schemes that are used by the most popular E2EE apps today. If you&rsquo;re impatient, you can skip through to the demo <a href="#demo">here</a>. Then, I&rsquo;ll detour into the basics of a couple cryptography primitives to recap this series&rsquo; prior two posts before covering the specific communication flows between recovery nodes. I&rsquo;ll also add some of my hard-learned lessons from implementing Kintsugi in Rust with libp2p and Tauri.</p>
<p>If you&rsquo;d prefer to watch through a video, you can find the recording <a href="https://fosdem.org/2025/schedule/event/fosdem-2025-5266-kintsugi-a-decentralized-e2ee-key-recovery-protocol/">here</a>. The slides are also available <a href="https://emilie.ma/talks/fosdem2025">here</a>. Tab back over to <a href="#implementation-details">the implementation details section</a> after you&rsquo;re done watching, since I don&rsquo;t cover the actual system architecture or the P2P app architecture in much depth in my live talk.</p>
<h2 id="background-context">Background Context</h2>
<figure><img src="../../img/250223/1.png"/>
</figure>

<p>So, to contextualize the problem space a bit, let&rsquo;s consider what happens when you lose your phone but want to regain access to data on some app you&rsquo;d installed. With a non-E2EE app, you can just download the app again and log in with the same username and password. Your password can be checked against whatever the app server stores, and the server can return your data. However, if the app is E2EE, then this isn&rsquo;t possible. The app server doesn&rsquo;t store your password, recovery key, or anything to help you decrypt whatever encrypted backup data is stored on the server. There are a couple main recovery mechanisms: to name a few, you can set a recovery PIN, some apps let you designate a recovery contact, or you could store recovery codes or hard copies of recovery files.</p>
<figure><img src="../../img/250223/2.png"/>
</figure>

<p>Unfortunately, these schemes each have tradeoffs. For example, Signal and WhatsApp <a href="https://signal.org/blog/secure-value-recovery/">both</a> <a href="https://faq.whatsapp.com/2183055648554771/">use</a> some sort of PIN-based system for recovery. You set your account&rsquo;s recovery PIN, a 4-to-6 digit code, from which a recovery key is derived and used to decrypt your backups. However, such a short code is easy to brute-force, so services must provide some form of rate-limiting. This usually relies on secure hardware, like <a href="https://en.wikipedia.org/wiki/Hardware_security_module">hardware security modules</a>, which will ensure that recovery attempts can only be performed once every so often. These HSMs are fairly expensive to run, though — Signal&rsquo;s preprod system, with a very limited scale, cost over $2K a month to run — and can be difficult to deploy.</p>
<p>There are also recovery contacts, where you can designate a friend or a group of contacts, to help you recover your account. <a href="https://support.apple.com/en-us/102641">Apple iCloud</a> is one such platform that lets you set up a recovery contact. The issue with social recovery schemes, though, is that you have to deeply trust your contacts. While, in some cases, you&rsquo;ll have to provide some personal information during recovery, as iCloud requires, this is often guessable. On some platforms like <a href="https://preveil.com/">PreVeil</a> that enable groups of recovery contacts, a threshold of contacts are able to collude behind your back to reconstruct your recovery key in entirety without your input or knowledge. This isn&rsquo;t good, as it essentially gives your recovery contacts all-powerful recovery access to your account (and remember that an account is only as secure as its least secure recovery option.)</p>
<p>Finally, some platforms like LastPass require you to store a set of recovery codes. Along the same lines, crypto wallets usually require you to store some seed phrase of 24 words or so, from which your private key is derived. These recovery codes are less prone to brute force concerns, since they&rsquo;re longer and higher-entropy, so you don&rsquo;t have to worry about expensive specialized hardware. On the other hand, this requires keeping a copy of the recovery codes or files around. Folks tend to misplace these, either digitally or physically, leading to total account lockout if you ever lose the files altogether. Also, because recovery codes are high-entropy and not as memorable as a password, it&rsquo;s much more difficult to commit them to memory.</p>
<figure><img src="../../img/250223/3.png"/>
</figure>

<p>These recovery schemes also rely on some centralized app provider or source of trust, and this centralization comes with its own drawbacks. The model of a central authority controlling all the servers and hardware associated with an app simply doesn&rsquo;t work for some contexts. For example, apps that require metadata privacy, like <a href="https://www.torproject.org/">Tor</a>, wouldn&rsquo;t work well with an all-powerful, potentially-malicious provider. Other applications may be at risk of having their infrastructure shut down if they need to run everything on a single cloud provider, or perhaps the service lacks the concept of a responsible, central authority in the first place, as is the case with instance-based forums, for example. Infrastructure can also be cost-prohibitive, especially if the platform&rsquo;s design requires specialized hardware, like the HSMs that Signal and WhatsApp use. Running these HSMs is complex and expensive, which limits the amount of decentralization possible — you can&rsquo;t really use a volunteer-based operator model like Tor does if the hobbyist contributors can&rsquo;t afford specialized hardware. Overall, while centralized recovery mechanisms work for existing apps, we wanted to explore a new space for recovery protocols in our research, particularly exploring schemes that were completely decentralized and didn&rsquo;t require any specialized hardware.</p>
<figure><img src="../../img/250223/4.png"/>
</figure>

<p>This is where Kintsugi comes in! It&rsquo;s a decentralized key recovery protocol based on a peer-to-peer network of recovery nodes. These nodes might be recovery servers run by different providers, end-user devices of social recovery contacts, like your friends, or a mix of the two. With Kintsugi, users recover their keys by providing their password and contacting some threshold <code>t+1</code> of recovery nodes. These recovery nodes each store some share of a secret that&rsquo;s needed to help the user reconstruct their key. Users can also update their recovery nodes at any time, which is something that&rsquo;s ideal in a context where we plan to apply Kintsugi to, for example, recover access to a collaborative doc where you have changing collaborators. Kintsugi defends against brute force attacks on the password, malicious, colluding recovery nodes, and can remain operational with offline nodes.</p>
<p>Before I go further into how Kintsugi works, though, I wanted to go through a quick demo just so you can get a sense of what Kintsugi can help us do.</p>
<h2 id="demo">Demo</h2>

<video src="../../img/250223/demo.mp4" controls="controls" muted="muted" style="max-width:100%;border-radius: 8px;margin-bottom: .8em"></video>

<p>You can check out the implementation for this demo <a href="https://github.com/kewbish/kintsugi">here</a>. Kintsugi is implemented as a P2P app in Rust, with <a href="https://libp2p.io/">libp2p</a> for the communication layer and <a href="https://v2.tauri.app/">Tauri</a> with React for the demo app&rsquo;s UI — more about this implementation <a href="#implementation-details">later</a>. This demo just shows the UI of the &ldquo;user&rsquo;s&rdquo; node, but each Kintsugi node can serve as a recovery node for other Kintsugi nodes, and there&rsquo;s no distinction between &ldquo;users&rdquo; and &ldquo;recovery servers&rdquo;.</p>
<p>In this video here, I walk through a user registering with a service that uses Kintsugi. Let&rsquo;s say this service is an encrypted notepad service, and for simplicity, all you can do is read and write to a locally encrypted file. In this case, Kintsugi is used to protect the key used to encrypt this file.</p>
<ul>
<li>In the video, we first walk through registration. The user chooses their username and password, then configures their recovery nodes. The service can also do this opaquely in the background for the user. We&rsquo;re just using a set of bootstrap nodes that I&rsquo;m running separately in the background here.</li>
<li>Then, we write to the encrypted notepad.</li>
<li>Next, we delete the local login file to simulate device loss. This file holds the key that was used to encrypt the notepad, and is used for local login. So now, we no longer have a local copy of the key we need to decrypt the notepad.</li>
<li>We then initiate recovery from our recovery node peers. The mapping from username to recovery nodes is stored in a <a href="https://en.wikipedia.org/wiki/Distributed_hash_table">distributed hash table</a> that can be queried globally without knowing any particular recovery data. We then initiate a recovery request with our username and password, which starts communicating with our recovery nodes behind the scenes.</li>
<li>Now, we can see that the keypair was successfully recovered and that we&rsquo;re logged back in. As well, the notepad can now be decrypted, and we can read back what we wrote earlier. Finally, local login works again, since we&rsquo;ve persisted our key locally again.</li>
<li>We can also change the set of recovery nodes or the threshold for recovery and repeat the same recovery process. This is Kintsugi&rsquo;s recovery node refresh flow.</li>
</ul>
<h2 id="background-context-bis">Background Context, bis</h2>
<p>(This section will duplicate content from the previous blog posts about OPRFs and Lagrange interpolation, but I&rsquo;m keeping it in here because someone mentioned that the diagrams very clearly explained the math, and to be honest I&rsquo;m still riding the high from the acknowledgement!)</p>
<figure><img src="../../img/250223/5.png"/>
</figure>

<p>I&rsquo;ll keep the crypto light to keep things accessible, but I wanted to briefly cover the basic concepts behind the main building blocks of Kintsugi here. For one, the cryptographic primitive we use to preserve E2EE properties and ensure that the recovery nodes can&rsquo;t find out anything about the user&rsquo;s password or final recovery key was via an <em>Oblivious Pseudo-Random Function</em>, or an OPRF.</p>
<p>An OPRF is a type of function where a user inputs a secret value, which we can call <code>U</code>, and their server inputs their own secret value, which we can call <code>S</code>. Evaluating an OPRF requires both the user and server to provide their secret values. However, only the user learns the function&rsquo;s output, <code>F(U, S)</code>, whereas the recovery nodes that participated don&rsquo;t learn anything at all: specifically, not the output of the function. Neither party learns anything about the other&rsquo;s secret value.</p>
<p>How does this work? The key is in what we call <em>blinding</em>. You can think of this as wrapping a secret present, like a top hat, in some wrapping paper. The user first blinds their secret value <code>U</code> before sending it to the server, so the server can&rsquo;t actually see what <code>U</code> is. Then, the server operates on this blinded value — maybe think of this as some magic machine that transmutes the secret present into pure gold and gives it back to you. Then, you get to unwrap your present — unblind your output — and enjoy the end result. The server doesn&rsquo;t see what your secret was, but you also don&rsquo;t know metaphorically how the server turned your secret present into gold: by analogy, you don&rsquo;t learn the server&rsquo;s secret <code>S</code> during this evaluation either.</p>
<figure><img src="../../img/250223/6.png"/>
</figure>

<p>The other main concept used in Kintsugi is <em>secret sharing</em>. This is how we&rsquo;re able to decentralize the key recovery and distribute trust across multiple recovery nodes. If you&rsquo;ve heard of it before, we used an extension of the ideas in <a href="https://en.wikipedia.org/wiki/Shamir%27s_secret_sharing">Shamir Secret Sharing</a> (SSS). Forgive me if your eyes are glazing over at the sight of a polynomial on the slide, but I promise this is intuitive.</p>
<p>With SSS, there&rsquo;s some secret <code>S</code> we want to split up into shares, and we want to make sure we require at least <code>t+1</code> shares to reconstruct <code>S</code>.</p>
<p>Consider some function with a constant term of <code>S</code>. We can define some polynomial as the SSS polynomial as long as it passes through <code>S</code> at <code>x = 0</code>, so we&rsquo;re able to choose these coefficients at random. We can then take points on the polynomial at different x values, which will be the secret shares. With a technique called <a href="https://en.wikipedia.org/wiki/Lagrange_polynomial">Lagrange interpolation</a> and given enough shares, you can &ldquo;connect the dots&rdquo; given by each of the points and eventually find the unique polynomial that passes through all of the shares. Then you can compute the function at <code>x = 0</code> again, which gives you <code>S</code>. If a polynomial has <code>t</code> of these extra coefficient terms, then you have <code>t</code> variables, represented by a, b, and z, and so on, that you need to find the values of, and taking into consideration the extra <code>S</code> variable you need to also find, you need <code>t+1</code> points in order to solve for these <code>t+1</code> variables. The core TL;DR is that you take your secret <code>S</code>, draw some squiggly polynomial that goes through <code>S</code>, then take points on the curve that you can then connect back later to find your secret <code>S</code> again.</p>
<figure><img src="../../img/250223/7.png"/>
</figure>

<p>We used extensions of both OPRFs and Shamir Secret Sharing to actually build Kintsugi. In Kintsugi, we use threshold OPRFs, which are just like an OPRF, except that you have multiple servers, each with their own secret share. You send blinded requests to each of these servers, and you need to get a blinded execution back from t+1 of them to combine together before you unblind things to get your actual encryption key. This concept is explained in more detail in the <a href="https://eprint.iacr.org/2017/363">TOPPSS paper</a> by Jarecki et al.</p>
<p>As well, instead of Shamir Secret Sharing, we use a variant called dynamic, proactive secret sharing, where each recovery nodes&rsquo; secret values can be refreshed while keeping the overall shared secret <code>S</code> the same. This can be thought of as changing the points in the graph in the earlier slide, while keeping the overall value of <code>S</code> the same. We use dynamic, proactive secret sharing so the user can change their recovery nodes at any time — for example, if one becomes untrustworthy or goes permanently offline. Users can then make sure that old recovery nodes can&rsquo;t participate in any new reconstruction efforts, while keeping the shared secret, later used to derive their recovery key, the same. This is described in the <a href="https://eprint.iacr.org/2022/971">Long Live the Honey Badger paper</a> by Das et al.</p>
<h2 id="registration">Registration</h2>
<p>Now, let&rsquo;s finally get into the three main flows you saw in the demo video: registration, recovery, and updating the recovery nodes.</p>
<figure><img src="../../img/250223/8.png"/>
</figure>

<p>The first flow we saw in the demo is registration: users start with their password, which they blind. Recall that blinding is an operation that&rsquo;s easy for the user to perform and undo but that the server can&rsquo;t break, which prevents the recovery nodes from finding out the user&rsquo;s password. Users send this blinded password (represented by the yellow present) to their recovery nodes. Users need to get responses from at least <code>t+1</code> recovery nodes, where this <code>t</code> is a threshold that the user can choose during registration. Each of these <code>t+1</code> recovery nodes hold a share of a recovery secret. Note that you don&rsquo;t have to reach out to all of your recovery nodes during this process, so if some of them are down during registration that&rsquo;s fine.</p>
<p>The user takes the blinded password and combines it with the node&rsquo;s secret share via a threshold OPRF, represented by the blue present. Remember how I mentioned with threshold OPRFs, the other parties don&rsquo;t learn anything about the user&rsquo;s password or the final output, which only the user sees? In this case, the user takes the final output, unblinds it, and uses the OPRF evaluation result as another key. This OPRF result key is used to encrypt their recovery key and any recovery data they want to save. The blinding and the threshold-based communication here prevent the recovery nodes from mounting an offline brute-force attack. We call this encrypted backup the encrypted envelope, which is sent to the recovery nodes to be persisted.</p>
<h2 id="recovery">Recovery</h2>
<figure><img src="../../img/250223/9.png"/>
</figure>

<p>During recovery, the user performs a similar exchange: they blind their password and send it to the recovery nodes. Again, you don&rsquo;t have to reach all of your recovery nodes, just a threshold, so if some nodes are offline you can still proceed with recovery. The recovery nodes each combine the blinded password with their respective shares and return their blind OPRF evaluations to the user along with the encrypted envelope that they&rsquo;ve stored. The user reconstructs their encryption key via the returned OPRF evaluations and with Lagrange interpolation, and decrypts the encrypted envelope to get their recovery key back.</p>
<figure><img src="../../img/250223/10.png"/>
</figure>

<p>These nodes also perform rate-limiting as an additional layer of brute-force protection without requiring any secure hardware. Because you need to wait for a threshold of nodes to return results before you can attempt to reconstruct the key, you&rsquo;re limited by the slowest recovery node. As long as one recovery node correctly implements a recovery attempt rate limit (which we assume in our threat model), the attempts will be rate-limited overall as well. This gets you some nice decentralized rate limiting as a result.</p>
<p>Also, because no single recovery node has the whole recovery secret, you&rsquo;ll need a whole threshold of at least <code>t+1</code> nodes to collude in order to get access to the shared recovery secret. Even then, these colluding nodes must still perform a brute-force attack, since the user&rsquo;s password was blinded, so they can&rsquo;t directly decrypt the encrypted envelope that they&rsquo;ve persisted. This provides protection against colluding recovery nodes.</p>
<h2 id="refreshing-update-nodes">Refreshing Update Nodes</h2>
<figure><img src="../../img/250223/11.png"/>
</figure>

<p>If the user wishes to update their recovery nodes, they send a notification to the old recovery nodes. A threshold of the old recovery nodes then use dynamic, proactive secret sharing to refresh their shares, communicating second-order shares of shares to the new recovery nodes (represented by the pink robots). These new recovery nodes might overlap with the old recovery nodes significantly, or indeed be the same set of nodes, or be completely different. The new recovery nodes reconstruct their new shares with Lagrange interpolation, which are then used from this point onwards.</p>
<p>Intuitively, consider that the original secret is split into shares once at each of the original, blue recovery nodes. Each of those shares is split up again in the second step in passing on shares to the new recovery nodes (pink robots). This broadcast just changes which pink robots hold which sub-shares of the original secret, but the underlying shared recovery secret remains the same. If you&rsquo;re interested, I wrote a <a href="https://kewbi.sh/blog/posts/241229/">blog post</a> that explains dynamic proactive secret sharing more, but let&rsquo;s wrap up all this math and take a look at the concrete implementation instead.</p>
<h2 id="implementation-details">Implementation Details</h2>
<p>Kintsugi is written in Rust, and the GitHub repository is available <a href="https://github.com/kewbish/kintsugi">here under the MIT License</a>. The P2P communication builds on the <a href="https://libp2p.io/">libp2p</a> framework, primarily based on the <a href="https://docs.rs/libp2p-request-response/latest/libp2p_request_response/"><code>request-response</code></a> module. libp2p is used <a href="https://docs.libp2p.io/concepts/introduction/users/">by the likes of</a> Ethereum, IPFS, and Filecoin, to name a few. You can read more about its basic model <a href="https://docs.libp2p.io/concepts/fundamentals/overview/">here</a> and see the Rust tutorial <a href="https://docs.rs/libp2p/latest/libp2p/tutorials/ping/index.html">here</a>. The gist of libp2p is that it&rsquo;s structured as an event-based loop, with everything from peer discovery to actual protocol messages implemented as so-called <a href="https://docs.rs/libp2p/latest/libp2p/tutorials/ping/index.html#network-behaviour"><code>NetworkBehaviour</code>s</a> that can define event handlers.</p>
<p>The client UI was developed with the <a href="https://v2.tauri.app/">Tauri</a> framework, using React as a frontend framework for familiarity&rsquo;s sake. Tauri lets you invoke commands, which are defined in Rust, from JS, and likewise emit events, which are handled in JS, from Rust. Tauri requires you to restructure your Rust and web frontend a little: for example, it needed to hold all the mutable state, and it needed to get the right same async runtime plugged in. There were few resources with using it with another async library like libp2p — I found <a href="https://rfdonnelly.github.io/posts/tauri-async-rust-process/">this blog post</a> very helpful for figuring out how to wire libp2p and Tauri together.</p>
<p>The event loop has to be written as a separate future to be managed by the Tauri app handle, and Tauri and libp2p have to be connected via a separate <a href="https://doc.rust-lang.org/std/sync/mpsc/fn.channel.html"><code>mpsc::channel</code></a>. Here&rsquo;s the general architecture:</p>
<figure><img src="../../img/250223/architecture-diagram.png"/>
</figure>

<p>You can see this event loop <a href="https://github.com/kewbish/kintsugi/blob/master/src/main.rs#L334">here</a>. For UI events, the commands that are invoked by the Tauri JS side forward extra messages through the <code>mpsc::channel</code> to initiate libp2p requests. There&rsquo;s a receiver <a href="https://github.com/kewbish/kintsugi/blob/master/src/main.rs#L337">here</a> in the event loop that takes in messages from this channel. You need to forward messages via this channel due to how Tauri is managing node state and where the libp2p communication objects are available, scope-wise. Specifically, the <code>#[tauri::command]</code> commands have to take in all parameters from the UI on the JS side, so it doesn&rsquo;t have access to libp2p components. All these commands are responsible for is sending a message to . These libp2p messages are processed <a href="https://github.com/kewbish/kintsugi/blob/master/src/main.rs#L107">here</a> and <a href="https://github.com/kewbish/kintsugi/blob/master/src/main.rs#L146">here</a>, sending responses back or kicking off yet more requests.</p>
<p>We initially started building Kintsugi with the <a href="https://docs.rs/libp2p-gossipsub/latest/libp2p_gossipsub/">gossipsub module</a>, but there were some issues with <a href="https://github.com/libp2p/rust-libp2p/discussions/5696">gossipsub reporting <code>InsufficientPeers</code></a> even when there were multiple recovery nodes subscribed to a topic as well as problems with <a href="https://github.com/libp2p/rust-libp2p/discussions/5731">topic re-creation</a> that blocked development. Someone mentioned in the comments that it might have just been an issue with the <a href="https://github.com/libp2p/rust-libp2p/discussions/5696#discussioncomment-11786456">crate tagging</a>, but I didn&rsquo;t verify if this was the fix since I&rsquo;d already begrudgingly ported everything to the request-response module already anyways. The request-response model worked better with our final design anyways, since the user individually blinds their password for each recovery node and since the recovery nodes only want to communicate directly with the user instead of broadcasting message information around willy-nilly.</p>
<p>Peer discovery is handled by the <a href="https://docs.rs/libp2p/latest/libp2p/mdns/">mDNS module</a>, and for now only takes place on the local network. For distributing global information like the user to recovery node mapping, we use the built-in <a href="https://docs.rs/libp2p/0.55.0/libp2p/kad/index.html">Kademlia DHT module</a>. We had to add some record verification to check signatures and the well-formedness of messages (<a href="https://github.com/kewbish/kintsugi/blob/master/src/kad_interactions.rs#L91">here</a>), but the Kademlia module&rsquo;s event-based structure led to some very annoying callback hell and required a lot of state to be passed around (<a href="https://github.com/kewbish/kintsugi/blob/master/src/kad_interactions.rs#L88">example</a>). If you want to enable message filtering, for message verification, for instance, you have to write event listeners both for the first attempted write to the DHT as well as the filtering request that has to perform the actual write. This complicated event structure was one of my main frustrations with libp2p. It&rsquo;s likely because I don&rsquo;t come from an event-driven programming background, but I found the model to lead to convoluted code that was hard to visualize without drawing out an explicit data flow graph.</p>
<p>There were also limited examples for what I needed references for (e.g. a very stripped down Kademlia basic example without peer discovery), although the docs and <a href="https://github.com/libp2p/rust-libp2p/tree/master/examples">existing example apps</a> were mostly enough to piece things together. I also hadn&rsquo;t gotten much experience with async Rust beforehand, so there was an extra learning curve on top of the framework details, even after going through the <a href="https://rust-lang.github.io/async-book/">Async Rust handbook</a>.</p>
<p>One very nice thing about libp2p was that the network communication (at least over a local network, I didn&rsquo;t mess with any NAT hole-punching) worked flawlessly. As I was explaining my libp2p woes to someone one day, they mentioned that with P2P networks, it&rsquo;s usually always the network that causes issues. I&rsquo;m happy to report this wasn&rsquo;t the case at all. This was fairly surprising, since I was developing on <a href="https://en.wikipedia.org/wiki/Eduroam">eduroam</a> for most of the project, and I&rsquo;d expect there&rsquo;s plenty of firewalling and broadcast limitations implemented.</p>
<p>Some other implementation notes:</p>
<ul>
<li>I wouldn&rsquo;t recommend integrating Tauri with all the libp2p events in one fell swoop. Instead, I&rsquo;d suggest starting from a smaller example and adding on only when the basic communication is working, since this limits the amount of refactoring you need to do if something all goes wrong (e.g. if you need to switch <code>NetworkBehaviour</code>s). This sounds very intuitive, but it&rsquo;s very tempting to build out all the libp2p communication, then just slap Tauri on top, but it took ages to debug.</li>
<li>Sometimes when libp2p messages don&rsquo;t seem to be getting sent properly, check if you have a mutex deadlock somewhere, particularly if you&rsquo;re also letting Tauri manage your shared node state with an <code>Arc&lt;Mutex&lt;T&gt;&gt;</code> or something similar.</li>
<li>It was easy to overlook in the docs for <a href="https://v2.tauri.app/develop/state-management/#async-commands">async commands</a>, but make sure the Tauri app handler has its async runtime set properly (<a href="https://github.com/kewbish/kintsugi/blob/master/src/main.rs#L312">here</a>).</li>
<li>Migrating to Tauri&rsquo;s minor idiosyncrasies with all the annotations, and the event-based loop that libp2p required, gave the project a natural tendency towards putting all the code in one file so various callbacks would be in one place and there wouldn&rsquo;t be any scoping or visibility issues. At one point, my <code>main.rs</code> was some &gt;2K LoC, which was still tenable but unsustainable for explaining the project to anyone. It was more straightforward to refactor than expected, but again I&rsquo;d advise starting with a more logically separated crate structure from the get-go.</li>
</ul>
<p>Overall, libp2p took some time to get used to, particularly when integrating it with Tauri, but the event-loop-based approach is starting to grow on me as I&rsquo;m becoming more comfortable debugging issues. If I were to reimplement Kintsugi, I&rsquo;d be happy going with this stack again.</p>
<h2 id="conclusion">Conclusion</h2>
<p>So that&rsquo;s been a whirlwind walkthrough of Kintsugi: I&rsquo;ve walked through some of the reasons why existing E2EE key recovery methods are lacking, gone through some fun intros to crypto, and finally touched on how Kintsugi works. With Kintsugi, our main improvement over existing recovery methods is our focus on decentralization. We also don&rsquo;t require any expensive hardware, can tolerate device loss, provide brute-force resistance, and protect against colluding recovery nodes. Here&rsquo;s the &ldquo;money slide&rdquo; conclusion from the talk:</p>
<figure><img src="../../img/250223/12.png"/>
</figure>

<p>Kintsugi is currently perhaps on a bit of a pause. I&rsquo;ve finished the protocol demo that you can see on <a href="https://github.com/kewbish/kintsugi">GitHub</a>, after much libp2p wrangling and a frantic grind towards getting the demo fully functional for FOSDEM. After I wrapped up the MVP demo, I ended up needing to focus on moving to my next internship and prepping for the FOSDEM talk, and have since not had much time to make progress. There&rsquo;s still plenty to look forward to in the future though: I should really continue polishing up the implementation, as there&rsquo;s plenty of (noncritical) loose ends like Byzantine value agreeemtn that I haven&rsquo;t fully implemented yet. There&rsquo;ve also been some vague discussions of integration with the Ink &amp; Switch decentralized access control project <a href="https://www.inkandswitch.com/beehive/notebook/">Beehive</a>, and I&rsquo;ve gotten some other messages from and chatted with folks interested in potentially using Kintsugi&rsquo;s theory in their own E2E platforms.</p>
<p>Speaking of getting questions and emails, I&rsquo;m reminded of something my UBC supervisor said the last time I gave a talk, about how it&rsquo;s nice to take academic research to industry conferences, both since it encourages you to ensure your work can be repackaged and massaged into something that&rsquo;s immediately impactful to real developers, and for reaching a new audience beyond at-times stuffy academia with different considerations and goals. Getting to think through these questions is a nice side effect of the opportunity and a very-much-appreciated affirmation that my work matters in some small way. It&rsquo;s also unique feedback that helps you better think through and articulate the project in the future. For example, I got a couple reoccurring questions about what happens if some recovery nodes are down, or if not all the initial recovery nodes are reachable upon registration, so I&rsquo;ve tried to do a better job in this blog post to reiterate that only a threshold of nodes need to be reached.</p>
<p>I&rsquo;ll be presenting Kintsugi again at the International Workshop on Security Protocols in March, and the proceedings should be available not long after then. I&rsquo;ve set a reminder to update this post with a link to the paper once it&rsquo;s out, as it explains some of the finer-grained details with more nuance and clearer caveats. Leaving this as a placeholder here until I&rsquo;ve put it up — you can also feel free to subscribe to notifications on <a href="https://github.com/kewbish/kintsugi/issues/1">this GitHub issue</a>, as I&rsquo;ve also set a reminder to comment there once I can upload a version of the paper to the repo.</p>
<p>That&rsquo;s about it from Kintsugi for now, but I&rsquo;m also writing up my FOSDEM experience in a separate post. I only attended for the first day, but I&rsquo;ll still be touching on some of the other talks I attended and some &ldquo;survival tips&rdquo; in the vein of <a href="https://petersouter.xyz/fosdem-survival-guide/">these</a> <a href="https://ounapuu.ee/posts/2024/02/12/fosdem-2024/">posts</a>. If you&rsquo;re less concerned with cryptography and more interested in treasure hunts, tangents about trip planning, and survival guides, look forward to that being out next week!</p>


<style>
figure {
margin-bottom: .8em;
}
</style>


<div class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1">
<p>Elevator rides are &lt;2min, which converts to around ~260 words at an average speaking rate. This explainer was ~160 words, so maybe you&rsquo;d even have a chance to brandish a <a href="https://kewbi.sh/blog/posts/240811/">NFC ring</a> to exchange contact information to take further questions…&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</div>
</div><br></div><p><a href=../../posts >‹ go back</a></main><script data-goatcounter="https://yours-kewbish.goatcounter.com/count" async src="//gc.zgo.at/count.js"></script>
