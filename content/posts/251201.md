---
title: "An Advent CAPlendar"
publishDate: "2025-12-01T06:47:02-07:00"
description: "On my Christmas-y systems-y countdown."
series: post
---

## Introduction

For a couple years in high school, I dedicated my Decembers to Wastl's [Advent of Code](https://adventofcode.com/), a daily series of Christmas-themed programming puzzles. The regular cadence of problems kept the completionist in me hooked, and the problems were satisfyingly challenging beyond my ability. I lacked the background to make it through most days after the first week or two on my own, so I'd sheepishly poke around the subreddit the next morning for hints. Through AOC, I learned a lot of Python builtins like counters, zips, and list comprehensions, and it was always a fun activity to look forward to during December.

Last year, I found out about a similar project called [Advent of Distributed Systems](https://aods.cryingpotato.com/). AODS breaks up the [Fly.io Distributed Systems](https://fly.io/dist-sys/) challenges into weekly miniprojects, aiming to get you through to the final Raft KV store by the end of the month.

This fall, I realized I had a growing paper backlog and a bucket list of startups and technologies I'd like to get around to reading someday, but never made the time for. Inspired by the subject matter of AODS and the cadence of AOC, I'm putting together my own holiday countdown.

This post is my 2025 Advent CAPlendar, exploring topics in distributed systems (hence the [title pun](https://en.wikipedia.org/wiki/CAP_theorem)), databases, formal verification, and security. I'm planning to read some foundational papers like DynamoDB and Zookeeper as well as some newer works out of [MIT PDOS](https://pdos.csail.mit.edu/) and [Berkeley SkyLab](https://sky.cs.berkeley.edu/). There are also some neat systems startups and protocols that I keep hearing about, so I'm also planning to glean what I can about how they work from their documentation. You can see a calendar of topics below[^1].

{{< rawhtml >}}

<p style="font-size: 30px;font-family:'Playfair Display';text-align:center;font-style:italic">2025 Advent CAPlendar</p>
<div class="flex" style="border-radius: 8px;background-color: var(--sub-colour)">
<div id="calendar-grid">
<div class="date-blocker"></div>
</div>
</div>

<style>
#calendar-grid {
display: grid;
grid-template-columns: repeat(7, minmax(0, 1fr));
grid-template-rows: repeat(4, minmax(0, 1fr));
gap: 8px;
padding: 12px;
}
.date-blocker {
opacity: 0;
}
.date {
grid-column: auto !important;
font-size: 18px;
padding: 0.5rem;
position: relative;
cursor: pointer;
 flex: 1;
  min-height: 0;
  overflow: auto;
  align-self: stretch;
}
@media (max-width: 1500px) {
.date {
font-size: 16px;
}
}
@media (max-width: 1370px) {
.date-blocker {
display: none;
}
#calendar-grid {
grid-template-columns: 1fr;
grid-template-rows: repeat(auto-fit, minmax(0, 1fr));
}
.date {
font-size: 18px;
}
}
.date p {
line-height: normal !important;
margin-bottom: auto !important;
text-indent: 0 !important;
}
.date > .date-number{
position: absolute;
top: .5rem;
right: .5rem;
font-size: 14px;
}
.date-mystery {
background: hsl(from var(--dark-accent-colour) h s l / 0.5);
color: var(--muted-accent-colour);
cursor: not-allowed !important;
}
a.date {
display: block;
}
.date-wrapper {
  display: flex;
  flex-direction: column;
  min-height: 0;
  a {
	display: flex;
  flex-direction: column;
  flex: 1;
  }
}
form {
display: flex;
gap: .5em;
width: 100%;
}
#email:disabled, #email-submit:disabled {
cursor: not-allowed;
}
</style>

{{< /rawhtml >}}

I'm also trying something new and starting a [popup newsletter](https://craigmod.com/essays/popup_newsletters/) to accompany this series. Signing up will get you a short weekend roundup list of the posts that week. To assuage the privacy-conscious: I'll only use this for Advent CAPlendar-related posts, I'll be running this by hand (no external data processors, etc.), and I promise I'll be too busy studying for finals to think about spamming you otherwise!

{{< rawhtml >}}

<form id="email-form"
>
  <input type="email" name="email" required id="email" />
  <button type="submit" id="email-submit">Sign Up</button>
</form>
{{< /rawhtml >}}

## 1. The CAP and CAL Theorems {#day-1-CAP-and-CAL-Theorems}

I figured it'd be most fitting to start this calendar by referencing the titular pun itself. The [CAP theorem](https://en.wikipedia.org/wiki/CAP_theorem) is idea that a distributed system can only satisfy two of the following three guarantees:

- **C**onsistency: reads return the most recently written value. This behaviour is also known as the [linearizability](https://en.wikipedia.org/wiki/Linearizability) consistency level.
- **A**vailability: every request by a non-failing node receives a response. Note that this doesn't mean every request receives a response, which I think is the typical definition of uptime via high availability; it's predicated here on being received by a non-failing node.
- **P**artition tolerance: the system keeps behaving as-is even as arbitrary nodes fail.

The idea is that if you have a network partition, you can decide to either eschew consistency and just return responses, even if they're not the latest values, or stick to your guns and not respond to requests, sacrificing availability.

The CAP theorem got [picked on](https://arxiv.org/abs/1509.05393) [a bunch](https://blog.dtornow.com/the-cap-theorem.-the-bad-the-bad-the-ugly/). The most obvious argument is that the pithy "pick 2 out of 3" framing conveniently sidesteps that you can't ignore partition tolerance, or that you might end up with less than two properties. As well, if your system doesn't fit the definitions of consistency (e.g. isn't linearizable), the CAP theorem shrugs its shoulders and gives up — it won't really tell you anything. [Martin Kleppmann's paper](https://arxiv.org/abs/1509.05393) also highlights some vagueness in definitions in the original CAP proof. This is summarized in [Dominik Tornow's blog post](https://blog.dtornow.com/the-cap-theorem.-the-bad-the-bad-the-ugly/), which illustrates how the conjecture and proof are a bit like passing ships in the night given their definitions are a bit off.

The CAP theorem could be a good rule of thumb, but I think its variants that focus on latency instead are far more interesting. [PACELC](https://en.wikipedia.org/wiki/PACELC_design_principle) is an extension of CAP, stating that under **P**artitioning, you have to choose between **A**vailability and **C**onsistency, **E**lse you'll have to make the tradeoff between **L**atency and **C**onsistency. This makes sense, since in the absence of partitions stronger consistency models will still impose more acknowledgements and latency.

Kleppmann's paper goes further, modelling availability in terms of operation latency to match more industry-standard intuitions of uptime SLAs. "If a service can sustain low operation latency, even as network delay increases dramatically, it is more tolerant of network problems than a service whose latency increases." sounds easier to compare to real systems. He also defines some operation latency lower bounds in term of network latency at different consistency levels which clearly match intuition.

Almost a decade later, Edward Lee takes this even further, defining the [CAL theorem](https://arxiv.org/pdf/2109.07771). This trades off against **C**onsistency, **A**vailability, and network **L**atency, but at a more gradual level than the all-or-nothing assumptions of the CAP theorem. The CAL theorem subsumes the CAP theorem, which is defined as a special case. It's a pity this isn't more widely known, otherwise I'd have a cleaner title for this Advent series.

I think the neatest part of Lee's paper is the [Lingua Franca](https://github.com/lf-lang/lingua-franca/) framework he introduces. It's a coordination language for distributed, realtime software for cyber-physical systems like autonomous vehicles. The key feature I picked up on was the fault handlers that trigger when you hit some apparent latency bounds, in which you can specify callbacks and explicitly define whether you'd like to relax your consistency or availability properties. If you choose to sacrifice availability, it provides centralized coordination primitives; if not it provides decentralized coordination with error bounds on clock synchronization to relax consistency. Lee has a video tutorial for how to do so [here](https://www.youtube.com/watch?v=3lHmiWOedHM). It looks like a nice abstraction layer to keep the CAL theorem top of mind while developing a distributed system.

I think the most valuable part of the CAP/CAL theorems for me is the quick gut check mental model. The CAP theorem appeals to instinctive sense. I also had the opportunity to attend Lee's Distinguished Lecture at UBC, and it was just as clearly laid out and intuitive. Writing this up has highlighted some of the caveats of each model, though, which I'll need to remember to keep in mind.

[^1]: After spending a while doing infra work, it was refreshing to go back to my frontend roots and put this together! I learned some new tricks: did you know [CSS has counters](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_counter_styles/Using_CSS_counters)? Did you know you can [set a separate header ID](https://www.markdownguide.org/extended-syntax/#heading-ids) or that you can [have slashes in them](https://stackoverflow.com/questions/27255591/using-forward-slash-as-id-attribute)?

{{< rawhtml >}}

<script>
for (let i = 1; i <= 25; i++) {
	const posts = document.querySelectorAll(`[id^=day-${i}]`);
	let isMystery = false;
	let title = "";
	let id = "";
	if (posts.length == 0) {
		isMystery = true;
		title = "—";
	} else {
		const post = posts[0];
		id = post.id;
		title = post.id.replace(`day-${i}-`, '').replaceAll("-", ' ', );
	}
	const element = document.createElement("div");
	element.classList.add("date");
	element.classList.add("grid-element");
	if (isMystery) {
		element.classList.add("date-mystery");
	}
	const number = document.createElement("p");
	number.classList.add("date-number")
	number.textContent = i;
	element.appendChild(number);
	const titleEl = document.createElement("p");
	titleEl.textContent = title;
	element.appendChild(titleEl);
	const parentWrapper = document.createElement("div");
	parentWrapper.classList.add("date-wrapper");
	if (!isMystery) {
		const wrapper = document.createElement("a");
		wrapper.href = "#" + id;
		wrapper.appendChild(element);
		parentWrapper.appendChild(wrapper);
		document.getElementById("calendar-grid").appendChild(parentWrapper);
	} else {
		parentWrapper.appendChild(element);
		document.getElementById("calendar-grid").appendChild(parentWrapper);
	}
}

document.getElementById('email-form').addEventListener('submit', async (e) => {
    e.preventDefault();
	const formEl = document.getElementById("email-form");
	const form = new FormData(formEl);

	fetch("https://courriel.kewbish.workers.dev/campaign/advent25/signup", {
	  method: "POST",
	  body: form
	});
	alert('Signed up!');
	document.getElementById('email').disabled = true;
	document.getElementById('email-submit').disabled = true;
});
</script>

{{< /rawhtml >}}
